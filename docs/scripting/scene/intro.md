---
sidebar_position: 1
title: Создание сцены
---

import '@site/src/css/pages/img-show.css';
import Mermaid from '@theme/Mermaid';

<div align="center">

# Что такое сцены и как с ними работать?

**Всё о том, как создавать сцены и работать с ними.**

<link rel="prefetch" as="image" href="@site/static/img/headers/scene.webp" />
<div className="cont"><div className="show" id="mask">
![Welcome](@site/static/img/headers/scene.webp)
</div></div>

---

</div>

## Что такое сцена?

Сцена — это автономный скрипт-объект, который описывает последовательность состояний (стейт-машину) и логику переходов между ними. Каждая сцена хранит своё внутреннее состояние в виде иерархии узлов.

Сцена определяет логику и последовательность действий (например, диалог, анимация, логика миссии и т. п.) в виде графа узлов, где переходы между узлами могут быть как явными (через `transition(path)`), так и неявными (когда внутри тела узла устанавливается специальный ключ `__state__` в его `CompoundTag`).

Например, у нас есть определённый квест, состоящий из множества состояний и развилок. В виде графа оно будет выглядеть как-то так:
<Mermaid
  value={`
graph TB
    Начало(("Начало"))
    Вступление(("Персонаж приходит к игроку и предлагает квест."))
    Выбор_квеста(("Игрок выбирает квест"))
    КвестА(("Спасти заложника"))
    КвестБ(("Похитить артефакт"))
    A1_Скрытность(("Игрок выбрал действовать скрытно."))
    A2_Прямой_бой(("Игрок решил идти напролом."))
    A1_Успех(("Игрок смог спасти заложника."))
    A1_Провал(("Игрока заметили."))
    A2_Успех(("Штурм удался"))
    A2_Провал(("Игрок проиграл"))
    B1_Переговоры(("Игрок решил попытаться договориться"))
    B2_Кража(("Игрок решил незаметно украсть артефакт"))
    B1_Успех(("Договоры прошли успешно"))
    B1_Провал(("Договоры провалились"))
    B2_Успех(("Артефакт украден"))
    B2_Провал(("Игрока заметили"))
    После_Квеста(("После квеста"))
    Финальный_Выбор(("Финальный выбор"))
    Конец_Добро(("Конец: Честь и справедливость"))
    Конец_Нейтрал(("Конец: Свой путь"))
    Конец_Зло(("Конец: Мощь через страх"))
    Начало --> Вступление
    Вступление --> Выбор_квеста
    Выбор_квеста -->|«Спасти заложника»| КвестА
    Выбор_квеста -->|«Похитить артефакт»| КвестБ
    КвестА -->|«Действовать скрытно»| A1_Скрытность
    КвестА -->|«Штурмовать»| A2_Прямой_бой
    A1_Скрытность -->|«Удача»| A1_Успех
    A1_Скрытность -->|«Провал»| A1_Провал
    A2_Прямой_бой -->|«Удача»| A2_Успех
    A2_Прямой_бой -->|«Провал»| A2_Провал
    A1_Успех --> После_Квеста
    A1_Провал --> A2_Прямой_бой
    A2_Успех --> После_Квеста
    A2_Провал -->|«Ранен, эвакуация»| После_Квеста
    КвестБ -->|«Переговоры»| B1_Переговоры
    КвестБ -->|«Кража»| B2_Кража
    B1_Переговоры -->|«Удача»| B1_Успех
    B1_Переговоры -->|«Провал»| B1_Провал
    B2_Кража -->|«Удача»| B2_Успех
    B2_Кража -->|«Провал»| B2_Провал
    B1_Успех --> После_Квеста
    B1_Провал --> B2_Кража
    B2_Успех --> После_Квеста
    B2_Провал -->|«Пойманы и отпущены»| После_Квеста
    После_Квеста --> Финальный_Выбор
    Финальный_Выбор -->|«Вернуться к людям»| Конец_Добро
    Финальный_Выбор -->|«Жить самостоятельно»| Конец_Нейтрал
    Финальный_Выбор -->|«Воспользоваться силой»| Конец_Зло

`}
/>

В коде вам нужно будет записать все эти состояния с различной логикой внутри каждого состояния, а также переходы между ними.

:::warning Как работают сохранения?
Если выйти из игры во время сцены, то движок сохранил лишь состояние, в котором находился игрок в этот момент и при перезапуске он начнёт это состояние заново.

Также Вы можете сохранять различные данные в хранилище состояния, об этом будет рассказано ниже.
:::

## Как создать сцену?

Для начала создайте новый скрипт-сцену и укажите в нём такую конструкцию:

```kts
script {
    state("main") {
        // Тут будет Ваш код
    }
}
```

По умолчанию при запуске скрипта он переходит в состояние `main`.

Чисто технически вы можете вообще забить на состояния и писать весь код прямо внутри script, но никакого сохранения тогда не будет.

## Как настроить сцену?

## Переменные

Прежде всего, помимо самих состояний вы можете также создавать переменные в скрипте.

Обратиться к этой переменной Вы сможете из любого состояния, например:

```kts
script {
    var power = 0
    
    state("main") {
        println(power)
    }
}
```

Но такая переменная будет сброшена при перезапуске, поэтому рекомендуется использовать конструкцию `remember(name: String, () -> T): Property<T>`:

```kts
script {
    var power: Int by remember("script_power") { 0 }
    
    state("main") {
        println(power)
    }
}
```

В этом случае он запишет вместе с данными скрипта и значение переменной.

Но помните, `remember` может сохранить не все данные, а только сериализуемые. Для этого используется библиотека KotlinX Serialization. Если не хотите в этом всём разбираться, то сохраняйте только примитивные типы (числа и строки)

## Переходы между состояниями

Чтобы перейти из одного состояния в другое используется метод `transition(name: String)`:

```kts
script {
    state("main") {
        transition("Ожидание") // Переходим в состояние "Ожидание"
    }
    
    state("Ожидание") {
        wait(10.sec)
        transition("main") // Можно вернутся в предыдущее состояние (Оно начнётся заново)
    }
}
```

Учтите, что `transition`, тут же останавливает текущее состояние и переходит в следующее, так что если его запустить в середине первого состояния, то закончив выполнение второго, он не вернётся к первому.

## Вложенные состояния

Вы можете создавать состояния внутри состояний. По умолчанию скрипт сам перейдёт во вложенное состояние:

```kts
script {
    state("main") {
        wait(10.sec)
        println("Запускаю скрипт")
        
        state("main") {
            println("Это вложенный main, он запустится после того, что прописано выше.")
            transition("Состояние 2")
        }
        
        state("Состояние 1") {
            println("Этот код запустится после второго состояния, потому что так прописано в переходе")
        }
        
        state("Состояние 2") {
            println("Этот код запустится сразу после вложенного main")
            transition("Состояние 1")
        }
    }
}
```

## Сложные переходы

При переходах вы можете спускаться с текущего уровня или подниматься на уровень выше:

```kts
script {
    state("main") {
        wait(10.sec)
        println("Запускаю скрипт")
        
        state("main") {
            println("Это вложенный main, он запустится после того, что прописано выше.")
            transition("../Ещё одно состояние") // Переход на уровень ниже относительно текущего состояния
        }
        
        state("Состояние 1") {
            println("Этот код запустится после второго состояния, потому что так прописано в переходе")
        }
        
        state("Состояние 2") {
            println("Этот код запустится сразу после вложенного main")
            transition("Состояние 1")
        }
    }
    
    state("Ещё одно состояние") {
        println("Переход сюда будет через вложенный main")
        transition("main/Состояние 2") // Переход на уровень выше относительно текущего состояния
    }
}
```

При необходимости в transition вы можете указывать локальный путь к разным состояниям:
- `transition("Ещё одно состояние")`: Переход в состояние на том же уровне.
- `transition("../Ещё одно состояние")`: Переход в состояние на уровень выше относительно текущего.
- `transition("./Состояние 1")`: Переход во вложенное состояние, которое объявлено внутри текущего (например внутри первого `main`). Учтите, что сначала вам нужно объявить само состояние, а уже потом переходить в него!
- `transition("/main/main")`: Переход в состояние начиная с корневого состояния. Как с путём начиная с диска `С:/` в Windows.

## Циклы, Ветвления, Корутины и прочая логика

Внутри состояний Вы можете писать код при помощи корутин. Это такой подход к разработке, когда Вы можете "Поставить код на паузу" до выполнения определённых функций, например:
- `wait(3.min + 12.sec)`: Приостановить выполнение состояния на 3 минуты 12 секунд
- `npc move pos(x, y, z)`: Приостановить выполнение состояния, пока Персонаж не дойдёт до координат [x, y, z].
- `player.waitPos(pos(x, y, z))`: Приостановить выполнение состояния, пока Игрок не дойдёт до координат [x, y, z].

Вы также всегда можете использовать обычные циклы и ветвления в комбинации с приостанавливаемыми методами, например:
```kts
script {
    val npc1 = ...
    val npc2 = ...
    val npc3 = ...
    val npc4 = ...
    
    val group = listOf(npc1, npc2, npc3, npc4)
    
    state("loop") {
        group.forEach { it move pos(x, y, z) } // Учтите, что при подобном подходе все нпс будут последовательно идти к точке по одному, а не все сразу
    }
    
    state("if") {
        group.forEach {
            if(it.health > it.maxHelth / 2) {
                it say "У меня со здоровьем всё хорошо"
            } else {
                it say "У меня со здоровьем всё плохо"
            }
        }
    }
}
```

## Асинхронные действия

Учитывая, что корутины приостанавливают выполнение скрипта, иногда Вам может потребоваться, чтобы выполнялось несколько приостанавливаемых действий одновременно. Для этого в системе предусмотрена возможность запуска асинхронных задач внутри состояний с помощью функции `async`.

Асинхронная задача не приостанавливает выполнение текущего состояния — вместо этого она запускается параллельно (внутри игрового корутинного контекста) и возвращает объект Deferred, с которым можно работать: ожидать завершения, проверять статус, отменять и т.д.

Но помните, `async` не сохраняется, как и всё кроме `remeber`, внутри state.

### Пример параллельного запуска
```kts
script {
    state("parallel") {
        val npc1 = ...
        val npc2 = ...

        // Оба нпс пойдут одновременно
        val job1 = async { npc1 move pos(10, 64, 10) }
        val job2 = async { npc2 move pos(15, 64, 15) }

        job1.join() // Ждёт, пока job1 не завершится
        job2.join()

        // Но код продолжится только когда оба дойдут до точки
        player.send("Оба NPC дошли до точки")
    }
}
```

В этом примере оба NPC начинают движение одновременно, и скрипт ждёт их окончания с помощью `join()`.

### Возможности async

#### Функция `Deferred.join()`

Ожидание завершения асинхронной задачи:
```kts
val job = async { wait(10.sec) }
job.join() // Ожидает завершения
```

#### Функция `Deferred.start()`
Можно указать, когда начинать выполнение задачи:

```kts
val job = async(start = CoroutineStart.LAZY) {
    npc move pos(10, 64, 10)
}
// Здесь задача ещё не запущена
job.start() // Явный запуск
```
Доступны режимы:
- `DEFAULT` — задача запускается сразу.
- `LAZY` — задача начнёт выполняться только после вызова `start()` или `await()` / `join()`.
- `ATOMIC` и `UNDISPATCHED` — для продвинутого использования.

#### Функция `Deferred.cancel()` / Параметр `Deferred.isActive`
Можно отменить задачу:
```kts
val job = async { ... }

if (!condition) job.cancel()

if (!job.isActive) {
    say("Задача была прервана")
}
```

### Групповое ожидание задач
Существует удобный способ ожидать множество задач:

```kts
val tasks = listOf(
    async { npc1 move pos(10, 64, 10) },
    async { npc2 move pos(15, 64, 15) },
    async { npc3 move pos(20, 64, 20) }
)

tasks.forEach { it.join() }

say("Все NPC дошли до точки")
```

#### Особенности
- `async` работает только внутри состояний, так как использует текущий игровой корутинный контекст.
- Вызовы внутри async {} не блокируют основной поток игры.
- Вы можете запускать логически параллельные действия, например:
  - Параллельные анимации 
  - Параллельные диалоги 
  - Сложные координации персонажей и объектов

